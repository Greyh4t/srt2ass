# coding:utf-8
import sys
import os
import re
import codecs
import chardet

input_file = sys.argv[1]
output_file = '.'.join(input_file.split('.')[:-1])

def fileopen(input_file):
    with open(input_file, 'rb') as tmp:
        file_str = tmp.read()
        coding = chardet.detect(file_str)['encoding']
        # print coding
        if ('UTF-16' in coding):
            tmp = file_str.decode('utf-16', 'ignore').encode('utf-8')
        elif ('GB2312' in coding or 'GBK' in coding):
            tmp = file_str.decode('gbk', 'ignore').encode('utf-8')
        elif ('Big5' in coding):
            tmp = file_str.decode('big5', 'ignore').encode('utf-8')
        else:
            tmp = file_str.decode('utf-8', 'ignore').encode('utf-8')
    return tmp


def srt2ass():
    head_str = '''[Script Info]
; Script generated by Aegisub 3.1.2
; http://www.aegisub.org/
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 720
PlayResY: 404
Aegisub Video Zoom Percent: 1.000000
Aegisub Scroll Position: 430
Aegisub Active Line: 437
Last Style Storage: Default
Synch Point: 1
Title: Game of Thrones S04E04
Original Translation: 衣柜
Original Editing: 衣柜
Script Updated By: 衣柜

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Titles,Microsoft YaHei,20,&H00C2E0EC,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1,1,2,10,10,10,1
Style: Subtitle,Microsoft YaHei,26,&H00C2E0EC,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1,1,2,10,10,4,1
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text'''
    
    tmp = fileopen(input_file)

    tmp = tmp + '\r\n\r\n'
    tmp = tmp.replace('{', '')
    tmp = tmp.replace('}', '')
    pattern = re.compile(r'(\d{1,2}:\d{1,2}:\d{1,2}),(\d{1,3})')
    tmp = pattern.sub(r'\1.\2', tmp)
    pattern = re.compile(r'\d{1,4}\r\n(\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3}) ?--> ?(\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3})\r\n(\\an\d\\pos\(.+\))')
    tmp = pattern.sub(r'Dialogue: 0,\1,\2,Titles,,0,0,0,,{\3\\fad(500,500)\\fs20}', tmp)
    pattern = re.compile(r'\d{1,4}\r\n(\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3}) ?--> ?(\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3})\r\n(\\pos\(.+\))')
    tmp = pattern.sub(r'Dialogue: 0,\1,\2,Titles,,0,0,0,,{\3\\fad(500,500)\\fs20}', tmp)
    pattern = re.compile(r'\d{1,4}\r\n(\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3}) ?--> ?(\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3})\r\n(\\an\d)')
    tmp = pattern.sub(r'Dialogue: 0,\1,\2,Titles,,0,0,0,,{\3\\fad(500,500)\\fs20}', tmp)
    pattern = re.compile(r'\d{1,4}\r\n(\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3}) ?--> ?(\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3})\r\n(.+)\r\n([ !\w\.,?\'\"-:;\(\)%$@&*\^+~<>]+)\r\n')
    tmp = pattern.sub(r'Dialogue: 0,\1,\2,Subtitle,,0,0,0,,\3\\N{\\fs18}\4', tmp)
    pattern = re.compile(r'\d{1,4}\r\n(\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3}) ?--> ?(\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3})\r\n(.+)\r\n\r\n')
    tmp = pattern.sub(r'Dialogue: 0,\1,\2,Subtitle,,0,0,0,,\3\n', tmp)
    pattern = re.compile(r'(\d{1,2}:\d{1,2}:\d{1,2}\.\d{2})\d')
    tmp = pattern.sub(r'\1', tmp)
    pattern = re.compile(r'\n')
    tmp = pattern.sub(r'\r\n', tmp)
    pattern = re.compile(r'\r\r\n')
    tmp = pattern.sub(r'\r\n', tmp)
    pattern = re.compile(r'\d{1,4}\r\n(\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3}) ?--> ?(\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3})\r\n\r\n\r\n')
    tmp = pattern.sub(r'', tmp)
    pattern = re.compile(r'\d{1,4}\r\n(\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3}) ?--> ?(\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3})\r\n(.+)\r\n(.+)\r\n')
    tmp = pattern.sub(r'Dialogue: 0,\1,\2,Subtitle,,0,0,0,,\3\\N\4', tmp)
    tmp = tmp.replace('\r\n', '\\N')
    tmp = re.sub(r'(\\N){1,8}', r'\\N', tmp)
    tmp = re.sub(r'(\\N){1,8}$', '', tmp)
    tmp = tmp.replace('\\NDialogue:', '\r\nDialogue:')

    output_str = head_str + '\n' + tmp
    # print output_str.decode('utf-8')
    
    with open(output_file + '.ass', 'wb') as output:
        output.write(codecs.BOM_UTF16_LE)
        output.write(unicode(output_str, 'utf-8').encode('utf-16-le'))


if __name__ == '__main__':
    srt2ass()
